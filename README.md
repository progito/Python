## ОП Python / 5. Объектно-ориентированное программирование в Python

### 5.1 Введение в ООП

**Объектно-ориентированное программирование** (ООП) - это стиль программирования, который основывается на использовании объектов, то есть некоторых абстрактных сущностей, которые представляют некоторые объекты или концепции в реальном мире. В Python есть множество возможностей для ООП.

Основные понятия ООП в Python:

- **Класс** - это шаблон для создания объектов. В классе определяются атрибуты (переменные, которые хранят данные) и методы (функции, которые могут менять данные или выполнять различные операции). Пример класса в Python:

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def say_hello(self):
        print("Hello, my name is", self.name)
```
_Этот класс определяет человека с именем и возрастом, а также методом say_hello, который выводит приветствие и имя человека._

- **Объект** - это экземпляр класса. Когда вы создаете объект на основе класса, вы получаете экземпляр этого класса, который содержит все методы и атрибуты, определенные в классе. Например:

```python
person1 = Person("John", 30)
```

_Эта строка создает объект person1 на основе класса Person._

- **Атрибуты** - это данные, которые хранятся в объекте. В объекте класса Person выше имя и возраст являются атрибутами.

- **Методы** - это функции, которые определены в классе и могут менять данные объекта или выполнять другие операции. Например, в классе Person выше метод say_hello - это метод.

В Python объектно-ориентированное программирование может использоваться для решения широкого круга задач: от простых сценариев до сложных систем. За ним проще поддерживать и развивать, и его можно использовать для создания модулей, библиотек и приложений.

### 5.2 Классы и объекты в Python
Давайте более подробно остановимся на классах и объектах. Еще раз - Классы и объекты в Python используются для создания новых типов данных. Класс описывает структуру объекта, его свойства и методы, а объект является экземпляром класса.

Пример класса, описывающего студента:

```python
class Student:
    def __init__(self, name, age, grade):
        self.name = name
        self.age = age
        self.grade = grade
        
    def get_info(self):
        return f"{self.name} is {self.age} years old and is in grade {self.grade}."
```

_Ключевое слово `class` используется для создания нового класса. `__init__` - это метод, который вызывается при создании нового объекта класса. В примере он инициализирует атрибуты `name`, `age` и `grade`. Метод `get_info` используется для получения информации о студенте._

Пример использования класса:

```python
s = Student("Alice", 12, 6)
print(s.get_info())
```

_Этот код создает новый объект класса `Student` с именем `s`, используя переданные значения для атрибутов. Затем он вызывает метод `get_info`, который возвращает строку, описывающую студента._

Можно создать множество объектов класса с разными значениями атрибутов:

```python
s1 = Student("Bob", 11, 5)
s2 = Student("Charlie", 13, 7)
print(s1.get_info())
print(s2.get_info())
```

_Оба объекта `s1` и `s2` являются экземплярами класса `Student`. Каждый объект имеет свои собственные значения атрибутов, но все они имеют одни и те же методы._

Некоторые из основных принципов ООП в Python включают **наследование**, **инкапсуляцию** и **полиморфизм**. Наследование позволяет создавать новые классы на основе уже существующих классов. Инкапсуляция означает, что данные класса являются приватными, что означает, что они не могут быть изменены снаружи класса. Полиморфизм позволяет использовать методы и функции классов с одинаковыми именами, но с разными параметрами.

Также можно создавать подклассы (концепция - наследование), которые наследуют атрибуты и методы базового класса:

```python
class HighSchoolStudent(Student):
    def get_info(self):
        return f"{self.name} is a high school student in grade {self.grade}."
```

_Этот подкласс `HighSchoolStudent` наследует все атрибуты и методы класса `Student`, но переопределяет метод `get_info`, чтобы добавить информацию о том, что это старшеклассник. _

Пример использования подкласса:

```python
h = HighSchoolStudent("David", 16, 10)
print(h.get_info())
```

_Этот код создает новый объект подкласса `HighSchoolStudent` с именем `h`, используя переданные значения для атрибутов. Затем он вызывает переопределенный метод `get_info`, который возвращает строку, описывающую старшеклассника. _

В Python классы и объекты используются часто и широко, и являются одним из основных инструментов ООП в языке программирования Python.
### 5.3 Наследование и полиморфизм
Наследование и полиморфизм - это ключевые понятия в объектно-ориентированном программировании (ООП). Оба понятия описывают способы повторного использования кода и являются важными для создания эффективных и гибких программ.

Наследование - это механизм, при котором новый класс создается на основе существующего класса. Новый класс наследует свойства и методы от родительского класса и может добавлять свои собственные свойства и методы. Наследование позволяет создавать новые классы на основе уже существующих, что упрощает их создание и снижает затраты на разработку.

**Пример наследования:**

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        print("")

class Dog(Animal):
    def speak(self):
        print("woof")
```

_Класс Dog наследует свойства и методы класса Animal, и добавляет свой собственный метод speak, который переопределяет метод speak класса Animal._
Полиморфизм - это способность объектов разных классов использовать одни и те же методы или функции. Полиморфизм позволяет работать с объектами различных классов, не зная их конкретного типа.

**Пример полиморфизма:**

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "woof"

class Cat(Animal):
    def speak(self):
        return "meow"

def animal_speak(animal):
    print(animal.speak())

dog = Dog("Buddy")
cat = Cat("Fluffy")

animal_speak(dog)
animal_speak(cat)
```

_Функция animal_speak работает с объектами разных классов, но вызывает один и тот же метод speak, что является примером полиморфизма._

Разница между наследованием и полиморфизмом заключается в их целях. Наследование используется для повторного использования кода и создания новых классов на основе существующих, а полиморфизм используется для работы с объектами разных классов, но обладающих одинаковым интерфейсом методов.

(дополнительно)

**Пример класса с инкапсуляцией**

```python
class Person:
    def __init__(self, name, age):
        self.__name = name  # приватное свойство
        self.__age = age    # приватное свойство

    # геттер для имени
    def get_name(self):
        return self.__name

    # геттер для возраста
    def get_age(self):
        return self.__age

    # сеттер для имени
    def set_name(self, name):
        self.__name = name

    # сеттер для возраста
    def set_age(self, age):
        self.__age = age

# Создаем объект класса Person
person = Person("John", 25)

# Используем геттеры для получения значений приватных свойств
print(person.get_name())  # John
print(person.get_age())   # 25

# Используем сеттеры для изменения значений приватных свойств
person.set_name("Jack")
person.set_age(30)

# Проверяем, что значения были изменены
print(person.get_name())  # Jack
print(person.get_age())   # 30
```

#### Публичные и праватные методы.
**Публичные методы (public methods)** - методы, к которым можно обращаться извне объекта. Они предоставляют интерфейс для взаимодействия с объектом. Обычно они имеют общепринятое имя и хорошо задокументированы, чтобы другие программисты могли легко использовать объект.

```python
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model

    def start_engine(self):
        print(f"Starting the engine of {self.make} {self.model}.")
```

**Публичные переменные (public variables)** - переменные, к которым можно обращаться извне объекта напрямую. Однако, в Python, использование прямого доступа к переменным объекта считается не совсем хорошей практикой, и обычно рекомендуется использовать геттеры и сеттеры (свойства) для управления доступом к переменным.

```python
class Person:
    def __init__(self, name):
        self.name = name
```

**Приватные методы (private methods)** - методы, к которым нельзя обратиться извне объекта напрямую. В Python, приватные методы обозначаются с помощью префикса _ (одно нижнее подчеркивание) перед именем метода.

```python
class Calculator:
    def __init__(self):
        self._result = 0  # Приватная переменная
        self._clear()

    def _clear(self):
        self._result = 0

    def add(self, x):
        self._result += x

    def get_result(self):
        return self._result
```

**Приватные переменные (private variables)** - переменные, к которым нельзя обратиться извне объекта напрямую. В Python, приватные переменные обозначаются с помощью префикса __ (двойное нижнее подчеркивание) перед именем переменной.

```python
class BankAccount:
    def __init__(self, account_number):
        self.__account_number = account_number  # Приватная переменная

    def get_account_number(self):
        return self.__account_number
```

**Основное отличие между** **публичными** и **приватными** элементами заключается в их доступности извне объекта. Приватные элементы предназначены для скрытия деталей реализации и предотвращения несанкционированного доступа к ним. Однако, в Python, приватные элементы все равно можно обойти, но считается хорошей практикой не использовать их напрямую извне объекта.

### 5.4 Основные типы методов класса (статические, классовые..). Сторонние методы класса.
**5.4.1** Статические методы и методы класса - это особые методы в объектно-ориентированном программировании в языке Python. 

Статические методы должны определяться с помощью аннотации @staticmethod перед их определением внутри класса. Они могут вызываться с использованием имени класса вместо экземпляра класса, и обычно они не имеют доступа к атрибутам класса или экземпляра. Статические методы обычно используются как вспомогательные методы, которые не зависят от состояния объекта. 

Методы класса должны определяться с помощью аннотации @classmethod перед их определением внутри класса. Они могут получать аргумент cls вместо self, и имеют доступ к атрибутам класса, а не экземпляра. Методы класса используются для связывания данных с классом, а не с экземпляром. 

Кроме статических и методов класса, есть обычные методы, которые определяются без аннотаций @staticmethod или @classmethod. Они могут получать аргумент self и иметь доступ к атрибутам экземпляра. Обычные методы используются для работ с конкретным экземпляром класса. 

Для лучшего понимания и применения этих методов важно учитывать принципы ООП и контекст использования методов в данном классе.

**5.4.2** Примеры сторонних методов класса:
- __add__() - используется для добавления элементов в объект класса. Он принимает в качестве первого аргумента ссылку на сам объект класса и, как правило, вторым аргументом передается элемент, который нужно добавить.
Пример использования метода `add()` в классе `MySet`:

```python
class MySet:
    def __init__(self):
        self.elements = []

    def add(self, element):
        if element not in self.elements:
            self.elements.append(element)
```

_Здесь метод add() используется для добавления элементов в множество `MySet`. Сначала проверяется, не присутствует ли элемент уже в множестве, и если его там еще нет, то он добавляется при помощи метода `append()`._
- __str__() - метод, который представляет объект в виде строки при использовании функции str();
- __len__() - метод, который возвращает количество элементов в объекте;
- __getitem__() и __setitem__() - методы, которые позволяют получить или установить значение для элемента по индексу.

Например:

```python
class MyList:
    def __init__(self):
        self.elements = []

    def add(self, element):
        self.elements.append(element)

    def __str__(self):
        return str(self.elements)

    def __len__(self):
        return len(self.elements)

    def __getitem__(self, index):
        return self.elements[index]

    def __setitem__(self, index, value):
        self.elements[index] = value
```

Теперь мы можем создать объект класса `MyList`, добавить в него несколько элементов и работать с ними как с обычным списком Python:

```python
my_list = MyList()
my_list.add(10)
my_list.add(20)

print(my_list)  # вывод: [10, 20]
print(len(my_list))  # вывод: 2
print(my_list[0])  # вывод: 10

my_list[1] = 30
print(my_list)  # вывод: [10, 30]
```

В целом, методы классов в Python помогают удобно организовывать и работать с объектами данного класса, а также предоставляют удобный интерфейс для взаимодействия с ними.

### 5.5 Понятие стека, очереди и дека.

**Стек, очередь и дека** – это структуры данных, которые используются для организации последовательности элементов. 

**Стек** представляет собой структуру данных, в которой элементы добавляются и удаляются только в одном конце – вершине стека. Последний элемент, добавленный в стек, будет первым элементом, который будет удален из стека. Это называется «принципом последнего вошел – первый вышел» (LIFO).

Пример кода на Python для работы со стеком:
``` python
stack = []
stack.append(1)
stack.append(2)
stack.append(3)
print(stack.pop()) # 3
print(stack.pop()) # 2
print(stack.pop()) # 1
```

**Очередь** – это структура данных, в которой элементы добавляются в конец и удаляются из начала. Первый элемент, добавленный в очередь, будет первым элементом, который будет удален из очереди. Это называется «принципом первым вошел – первый вышел» (FIFO).

Пример кода на Python для работы с очередью:
``` python
from collections import deque
queue = deque()
queue.append(1)
queue.append(2)
queue.append(3)
print(queue.popleft()) # 1
print(queue.popleft()) # 2
print(queue.popleft()) # 3
```

**Дека** (двусторонняя очередь) – это структура данных, в которой элементы могут быть добавлены или удалены как с начала, так и с конца очереди. Дека позволяет реализовать очередь или стек в зависимости от того, какие операции выполняются в деке.

Пример кода на Python для работы с декой:
``` python
from collections import deque
deque = deque()
deque.append(1)
deque.append(2)
deque.append(3)
print(deque.popleft()) # 1
print(deque.pop()) # 3
print(deque.popleft()) # 2
```

В Python стек, очередь и дека могут быть реализованы с помощью списка или коллекции deque из модуля `collections`. deque – это оптимизированная для быстрого добавления и удаления элементов двусторонняя очередь.
